import numpy as np
# МАССИВЫ - содержит один указатель на непрерывный блок дынных
# Массив с фиксированным типом, более эффективно хранит и обрабатывает данные.

# ПЕРЕВОД DATAFRAME В ARRAY
# df.to_numpy()


# СТАТИСТИКА
# boot_means = [162, 172.2, ...., 168.6]
# a = np.percentile(boot_means, [2.5, 97.5])  # array ([166.627975, 171.60705]) # 95% доверительный интервал


# СОЗДАНИЕ массивов
# np.array([1, 2, 3], dtype='float32' или dtype=int)  # для задания типа
# np.arange(10).reshape((2, 5))
# np.array([range(i, i+3) for i in [2, 3, 4]])  # для создания многомерных массивов
# print(np.full((2, 2), 3.14))  # [[3.14 3.14][3.14 3.14]]
# print(np.linspace(0, 1, 6))  # [0.  0.2 0.4 0.6 0.8 1. ]
# print(np.random.random((3, 3)))  # заполнение массива 3х3 случайными числами от 0 до 1
# print(np.random.normal(0, 2, (2, 2)))  # массив с медианой 0, стандартное отклонение 2
# print(np.random.randint(0, 10, (2, 3)))  # случайные числа от 0 до 10 размером 2х3

# np.random.seed(0) # начальное значение
x1 = np.random.randint(10, size=6)
x2 = np.random.randint(10, size=(3, 5))
x3 = np.random.randint(10, size=(3, 5, 6))
# ndim - размерность, shape - размер каждого измерения, size - общий размер массива
# print(x3.ndim, x3.shape, x3.size)  # 3 (3, 5, 6) 90
# print(x3.dtype)  # int32 тип

# print(np.arange(2, 9))  # [2 3 4 5 6 7 8]
# print(np.arange(2, 9, .5))  # [2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5]

# print(np.zeros((3, 4)))  # массив из нулей размером 3 на 4 (3 списка на 4 элемента каждый)
# np.ones((2, 3))  # тоже самое только из единиц
# print(np.eye(3))  # единичная матрица

# rand = np.random.RandomState(1)  # начальное значение задает для рандома
# print(rand.randint(100, size=10))  # [37 12 72  9 75  5 79 64 16  1]
# print(np.random.randint(-20, 100, size=10))  # [ 65  55 -13  88  98  27  14  18  86   5]   ИЛИ ТАК

# или использовать уже существующую размерность
# b = np.ones_like(a)

# поменять тип
# b = a.astype('str')

# ИНДЕКСАЦИЯ
m = np.array([[1, 2, 3],
             [4, 5, 6]])
# print(m[1, 2])  # 6

# m[l, n] где l и m массивы,содержащие элементы являющиеся индексами для массива m

# pairs[0][0] = 4  # присваивание нового значения
# СРЕЗЫ
# print(m[:1, :2])  # [[1 2]]
# m[::-1, ::-1]  # для переворота
# print(m[:, 1])  # [2 5] столбец
# СРЕЗЫ В NUMPY НЕ СОЗДАЮТ КОПИИ ИСХОДНОГО МАССИВА!!! для экономии пространства


# ИЗМЕНЕНИЕ РАЗМЕРОВ МАССИВОВ
scores = np.array([1, 2, 3, 4, 5, 6])
pairs = scores.reshape(3, 2)  # [[1 2][3 4][5 6]]
# print(pairs.ndim)  # 2 - число измерений
# print(pairs.transpose())  #[[1 3 5][2 4 6]]  # группировка по столбцам
# print(pairs.ravel())  # [1 2 3 4 5 6]  # в одномерный
# print(scores[:, np.newaxis])  #[[1][2][3][4][5][6]] лучше пользоваться им

# СЛИЯНИЕ МАССИВОВ
# np.concatenate([x, y, z])
# np.concatenate([x, y])  # так для двумерных массивов по первой оси координат
# np.concatenate([x, y, axis=1])  # так же но по второй оси координат
# np.vstack([])  # по вертикали для разномерных
# np.hstack([])  # по горизонтали для разномерных
# np.dstack([])  # по третьей оси
# РАЗБИЕНИЕ МАССИВОВ
x = [1, 2, 3, 99, 99, 3, 2, 1]
# x1, x2, x3 = np.split(x, [3, 5])
# print(x1, x2, x3)  # [1 2 3] [99 99] [3 2 1]
# upper, lower = np.vsplit(grid, [2])
# left, right = np.hsplit(grid, [2])
# np.dsplit()  # по 3 оси


# ВЫПОЛНЕНИЕ ОПЕРАЦИЙ
# библиотека numpy предоставляет статическую типизацию (векторизованные операции)(векторизация операций).
# используя универсальные функции

# -(0.5*x + 1) ** 2  # любые операции
L = np.arange(0, 2, 0.1)
# print(L.round())  # округление до целых чисел
# L.round(2)  # округление до какого знака
# np.floor(L)  # округление в меньшую сторону
# np.ceil(L)  # округление в большую сторону
# np.add(L, 2)  # +2 к каждому элементу массива
# np.subtract(L, 1)  # -1
# np.sum(L)  # сумма элементов массива
# np.prod(L)  # произведение

# Указание массива для вывода результата
# x = np.arange(5)
# y = np.empty(5)
# np.multiply(x, 10, out=y)
# print(x, y)  # [0 1 2 3 4] [ 0. 10. 20. 30. 40.]
# np.power(2, x, out=y[::2])  # или для вывода через интеррвал 2

# np.sum(L) работает БЫСТРЕЕ, чем sum(L)  (выполнение операции в скомпилированном коде)
# np.max(m), np.max(m), np.mean(среднее знач) тоже БЫСТРЕЕ чем просто m.max
# np.argmax, np.argmin  индекс макс и мин арг (первого)

grades = np.array([[5, 4, 3, 3, 4],
                   [4, 4, 3, 3, 5],
                   [3, 3, 4, 5, 5]])
# print(np.mean(grades, axis=0)) [4.    3.66666667 3.33333333 3.66666667 4.66666667] ср.зн.по столбцу
# print(np.sum(grades, axis=0))  [12 11 10 11 14]

# nan - безопасные функции
# np.nanstd - стандартное отклонение
# var - дисперсия
# median - медиана
# any, all - есть ли true, все ли true


# СРАВНЕНИЯ, МАСКИ И БУЛЕВА ЛОГИКА
# m = (grades >= 3) & (grades <= 6)
# m.sum()  # так как в массиве тру и фолс, то сумма единиц будет
# np.sum(x < 7, axis=1)
# или = |, и = &
# print(grades[(grades > 2) & (grades < 5)])  # [4 3 3 4 4 4 3 3 3 3 4]
# np.any(x>6)
# np.sum((x>6) & (x<10))

# МАСКИРОВАНИЕ
# print(grades[grades > 4])  # [5 5 5 5]
# summer = (np.arange(365) - 172 < 90) & (np.arange(365) - 172 > 0)


# ТРАНСЛИРОВАНИЕ - набор правил по применению бинарных универсальных функций.
a = np.array([0, 1, 2])
# a + 5 - транслирование
b = np.arange(2)[:, np.newaxis]
# print(a+b)

# ЦЕНТРИРОВАНИЕ массива - вычитание из массива его среднего значения. Среднее знач центрированного
# массива равно примерно 0


# ПРИХОТЛИВАЯ ИНДЕКСАЦИЯ
# print([a[0], a[1], a[2]])  # [0, 1, 2]
# или так
# b = [0, 1, 2]
# print(a[b])  # [0, 1, 2]

# row = np.array([0, 2, 3])
# col = np.array([2, 3, 4])
# x[row, col]  # вывод элементов двумерного массива
# или
# x[row[:,np.newaxis], col]  # вывод элементов массива в виде двумерного массива

# ПРИМЕР
# X[2, [2, 0, 1]]
# X[1:, [2, 0, 1]]

# ВЫБОРКА СЛУЧАЙНЫХ ТОЧЕК
mean = [0, 0]
cov = [[1, 2],
       [2, 5]]
rand = np.random.RandomState(0)
X = rand.multivariate_normal(mean, cov, 100)
# print(X.shape)  # (100, 2)
indices = np.random.choice(X.shape[0], 20, replace=False)
# print(indices)  # индексы строк, где пара - координата точки
selections = X[indices]
# print(selections)  # вывод 20 случайных точек


# ИЗМЕНЕНИЕ ЗНАЧЕНИЙ
# x = np.arange(10)
# i = np.array([1, 3, 5, 7, 9])
# x[i] = 99  # x[[1, 3, 5, 7, 9]] = 99
# print(x)  # [ 0 99  2 99  4 99  6 99  8 99]
# x[i] -= 10
# print(x)  # [ 0 89  2 89  4 89  6 89  8 89]
# y = np.zeros(10)
# print(y)  # [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
j = np.array([1, 1, 3, 3, 5])
# np.add.at(y, j, 1)  # функция at() для повторяющихся индексов
# print(y)  # [0. 2. 0. 2. 0. 1. 0. 0. 0. 0.]


# СОРТИРОВКА
# np.sort  np.argsort
# x = np.array([2, 1, 4, 3, 5])
# y = np.sort(x)
# print(np.argsort(x))  # [1 0 3 2 4] возвращает индексы
# np.sort(X, axis=0)  # сортировка элементов в столбцах

# ЧАСТИЧНАЯ СОРТИРОВКА
# print(np.partition(x, 3))  # [3 2 1 4 5] первые 3 элемента наименьшие
# print(np.partition(x, 3, axis=0))  # так и для многомерных массивов
# np.argpartition()  # индексы


# К - БЛИЖАЙШИЕ СОСЕДИ
# x = rand.rand(10, 2)
# print(x)
# y = x[:, np.newaxis, :] - x[np.newaxis, :, :]
# print(y)


# ЛОГАРИФМИЧЕСКАЯ ШКАЛА
# print(np.log(scores))  # [0.         0.69314718 1.09861229 1.38629436 1.60943791 1.79175947]

# ОПЕРАЦИИ


# РАБОТА С ДАТАМИ
# t1 = '2019-02-20'
# t2 = '2019-02-25'
# t1 = np.datetime64(t1)
# t2 = np.datetime64(t2)
# print(t2 - t1) # 5 days

# СТРУКТУРИРОВАННЫЕ МАССИВЫ
# info = np.array([('Anna', 19, 168), ('Sam', 20, 155.5), ('Ilya', 25, 180.1)],
#                 dtype=[('name', 'U10'), ('age', int), ('height', float)])
# print(info)  # [('Anna', 19, 168. ) ('Sam', 20, 155.5) ('Ilya', 25, 180.1)]
# print(info[0])  # ('Anna', 19, 168.)  вывод строки
# print(info['age'])  # [19 20 25]  вывод столбца
# print(info[['age', 'height']])  # [(19, 168. ) (20, 155.5) (25, 180.1)]  вывод пары
# print(info['age'][0])  # 19
# ФИЛЬТРАЦИЯ
# fil = info[info['age'] >= 20]['name']
# print(fil)  # ['Sam' 'Ilya']


# ЧТЕНИЕ \ ЗАПИСЬ
# np.save('info.npy', info)  # запись в файл

# new = np.load('info.npy')  # чтение из файла
# print(new)  # [('Anna', 19, 168. ) ('Sam', 20, 155.5) ('Ilya', 25, 180.1)]
# np.savetxt('score.txt', scores)

scores = np.array([[20, 40, 56, 80, 0, 5, 25, 27, 74, 1],
         [0, 98, 67, 100, 8, 56, 34, 82, 100, 7],
         [78, 54, 23, 79, 100, 0, 0, 42, 95, 83],
         [51, 50, 47, 23, 100, 94, 25, 48, 38, 77],
         [90, 87, 41, 89, 52, 0, 5, 17, 28, 99],
         [32, 18, 21, 18, 29, 31, 48, 62, 76, 22],
         [6, 0, 65, 78, 43, 22, 38, 88, 94, 100],
         [77, 28, 39, 41, 0, 81, 45, 54, 98, 12],
         [66, 0, 88, 0, 44, 0, 55, 100, 12, 11],
         [17, 70, 86, 96, 56, 23, 32, 49, 70, 80],
         [20, 24, 76, 50, 29, 40, 3, 2, 5, 11],
         [33, 63, 28, 40, 51, 100, 98, 87, 22, 30],
         [16, 54, 78, 12, 25, 35, 10, 19, 67, 0],
         [100, 88, 24, 33, 47, 56, 62, 34, 77, 53],
         [50, 89, 70, 72, 56, 29, 15, 20, 0, 0]])

nonzero = np.array(scores[scores > 0])
no_zero = np.sum(scores > 0, axis=1)


# a = np.array([1, 3, 0], float)
# np.logical_and(a > 0, a < 3)
# b = ((a > 0) & (a < 3))
# print(type(b))

